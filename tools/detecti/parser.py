import sb.parse_utils # for sb.parse_utils.init(...)
import io, tarfile, json    # if the output parameter is used

VERSION: str = "2025/06/2"
"""identify the version of the parser, e.g. '2022/08/15'"""

FINDINGS: set[str]  = {
    "reentrancy", 
    "timestamp", 
    "unchecked-return",
}
"""set of strings: all possible findings, of which 'findings' below will be a subset"""

"""
    Analyse the result of the tool tun.

    :param exit_code: int|None, exit code of Docker run (None=timeout)
    :param log: list[str], stdout/stderr of Docker run
    :param output: bytes, tar archive of files generated by the tool (if specified in config.yaml)

    :return: tuple[findings: list[dict], infos: set[str], errors: set[str], fails: set[str]]
      findings identifies the major observations of the tool,
      infos contains any messages generated by the tool that might be of interest,
      errors lists the error messages deliberately generated by the tool,
      fails lists exceptions and other events not expected by the tool,
      analysis contains any analysis results worth reporting
"""
def parse(exit_code, log, output):
    findings, infos = [], set()
    errors, fails = sb.parse_utils.errors_fails(exit_code, log)

    try:
        with io.BytesIO(output) as o, tarfile.open(fileobj=o) as tar:
            output_json = tar.extractfile("output.json").read()
            output_dict = json.loads(output_json)
    except Exception as e:
        fails.add(f"error parsing results: {e}")
        output_dict = {}

    if output_dict:
        reentrancy = output_dict["reentrancy"]["results"]
        timestamp = output_dict["timestamp dependence"]["results"]
        unchecked_return = output_dict["unchecked return value"]["results"]
        
        if len(reentrancy) > 0:
            for issue in reentrancy:
                finding = {}
                if issue["result"] == "True Positive":
                    finding["name"] = "reentrancy"
                    finding["filename"] = issue.get("file", "").replace("/sb/","")
                    finding["contract"] = issue.get("contract", "")
                    finding["function"] = issue.get("function", "")
                    findings.append(finding)
        
        if len(timestamp) > 0:
            for issue in timestamp:
                finding = {}
                if issue["result"] == "True Positive":
                    finding["name"] = "timestamp"
                    finding["filename"] = issue.get("file", "").replace("/sb/","")
                    finding["contract"] = issue.get("contract", "")
                    finding["function"] = issue.get("function", "")
                    findings.append(finding)

        if len(unchecked_return) > 0:
            for issue in unchecked_return:
                finding = {}
                if issue["result"] == "True Positive":
                    finding["name"] = "unchecked-return"
                    finding["filename"] = issue.get("file", "").replace("/sb/","")
                    finding["contract"] = issue.get("contract", "")
                    finding["function"] = issue.get("function", "")
                    findings.append(finding)

    return findings, infos, errors, fails
    """
    findings is a list of issues. Each issue is a dict with the following fields.
    name: str
        mandatory. Identifies the type of issue
    filename: str
        optional. Path of file processed. As this is the path within
        the docker image, it will be replaced by the external filename,
        after parsing.
    contract: str
        optional. Name of contract within the file (for source code)
    function: str
        optional. Name/header/signature of function containing the issue
    line: int
        optional. Line number of issue in source code, starting with 1
    column: int
        optional. Column of issue in source code, starting with 1
    line_end: int
        optional. Last line of the source code, where issue occurs.
    column_end: int
        optional. Last column of the source code, where issue occurs.
    address: int
        optional. Address of instruction in the bytecode, where issue occurs, starting with 0
    address_end: int
        optional. Address of last instruction in the bytecode, where issue occurs, starting with 0
    exploit: Any
        optional. Information on a potential exploit, e.g. a list of transactions
    level: str
        optional. type of issue, e.g. recommendation, warning, error
    severity: str
        optional. Severity of issue, e.g. low, medium, high
    message: str
        optional. Description of the issue

    If missing, the fields severity, classification, method, descr_short,
    descr_long will be taken from the file findings.yaml in the tools
    directory (if it exists), with "name" serving as the key.
    """

